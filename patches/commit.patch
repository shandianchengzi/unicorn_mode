diff --git a/bindings/python/unicorn/arm_const.py b/bindings/python/unicorn/arm_const.py
index 088eaa4..abb15ff 100644
--- a/bindings/python/unicorn/arm_const.py
+++ b/bindings/python/unicorn/arm_const.py
@@ -120,7 +120,8 @@ UC_ARM_REG_IPSR = 114
 UC_ARM_REG_MSP = 115
 UC_ARM_REG_PSP = 116
 UC_ARM_REG_CONTROL = 117
-UC_ARM_REG_ENDING = 118
+UC_ARM_REG_XPSR = 118
+UC_ARM_REG_ENDING = 119
 
 # alias registers
 UC_ARM_REG_R13 = 12
diff --git a/config.mk b/config.mk
index c3621fb..89347ae 100644
--- a/config.mk
+++ b/config.mk
@@ -8,7 +8,8 @@
 # Compile with debug info when you want to debug code.
 # Change this to 'no' for release edition.
 
-UNICORN_DEBUG ?= yes
+# UNICORN_DEBUG ?= yes
+UNICORN_DEBUG ?= no
 
 ################################################################################
 # Specify which archs you want to compile in. By default, we build all archs.
diff --git a/include/unicorn/arm.h b/include/unicorn/arm.h
index a0fd83e..5a0c81f 100644
--- a/include/unicorn/arm.h
+++ b/include/unicorn/arm.h
@@ -137,6 +137,7 @@ typedef enum uc_arm_reg {
     UC_ARM_REG_MSP,
     UC_ARM_REG_PSP,
     UC_ARM_REG_CONTROL,
+    UC_ARM_REG_XPSR,
     UC_ARM_REG_ENDING,		// <-- mark the end of the list or registers
 
     //> alias registers
diff --git a/qemu/cpu-exec.c b/qemu/cpu-exec.c
index b955964..47c4fb7 100644
--- a/qemu/cpu-exec.c
+++ b/qemu/cpu-exec.c
@@ -24,6 +24,9 @@
 
 #include "uc_priv.h"
 
+#include "../../patches/afl-unicorn-cpu-inl.h"
+static int afl_first_instr = 0;
+
 static tcg_target_ulong cpu_tb_exec(CPUState *cpu, uint8_t *tb_ptr);
 static TranslationBlock *tb_find_slow(CPUArchState *env, target_ulong pc,
         target_ulong cs_base, uint64_t flags);
@@ -246,6 +249,8 @@ int cpu_exec(struct uc_struct *uc, CPUArchState *env)   // qq
                             next_tb & TB_EXIT_MASK, tb);
                 }
 
+                AFL_UNICORN_CPU_SNIPPET2;
+
                 /* cpu_interrupt might be called while translating the
                    TB, but before it is linked into a potentially
                    infinite loop and becomes env->current_tb. Avoid
@@ -416,6 +421,8 @@ not_found:
         return NULL;
     }
 
+    AFL_UNICORN_CPU_SNIPPET1;
+
 found:
     /* Move the last found TB to the head of the list */
     if (likely(*ptb1)) {
diff --git a/qemu/target-arm/translate.c b/qemu/target-arm/translate.c
index 12cdd71..3ec36f5 100644
--- a/qemu/target-arm/translate.c
+++ b/qemu/target-arm/translate.c
@@ -4160,8 +4160,9 @@ static void gen_nop_hint(DisasContext *s, int val)
 {
     switch (val) {
     case 3: /* wfi */
-        gen_set_pc_im(s, s->pc);
-        s->is_jmp = DISAS_WFI;
+        // Tobias: We don't want the execution to halt upon a normal WFI instruction
+        //gen_set_pc_im(s, s->pc);
+        //s->is_jmp = DISAS_WFI;
         break;
     case 2: /* wfe */
         gen_set_pc_im(s, s->pc);
diff --git a/qemu/target-arm/unicorn_arm.c b/qemu/target-arm/unicorn_arm.c
index 5ff9ebb..ecffdb6 100644
--- a/qemu/target-arm/unicorn_arm.c
+++ b/qemu/target-arm/unicorn_arm.c
@@ -68,6 +68,9 @@ int arm_reg_read(struct uc_struct *uc, unsigned int *regs, void **vals, int coun
             *(float64 *)value = ARM_CPU(uc, mycpu)->env.vfp.regs[regid - UC_ARM_REG_D0];
         else {
             switch(regid) {
+                case UC_ARM_REG_XPSR:
+                    *(int32_t *)value = xpsr_read(&ARM_CPU(uc, mycpu)->env);
+                    break;
                 case UC_ARM_REG_APSR:
                     *(int32_t *)value = cpsr_read(&ARM_CPU(uc, mycpu)->env) & (CPSR_NZCV | CPSR_Q | CPSR_GE);
                     break;
@@ -134,6 +137,9 @@ int arm_reg_write(struct uc_struct *uc, unsigned int *regs, void* const* vals, i
             ARM_CPU(uc, mycpu)->env.vfp.regs[regid - UC_ARM_REG_D0] = *(float64 *)value;
         else {
             switch(regid) {
+                case UC_ARM_REG_XPSR:
+                    xpsr_write(&ARM_CPU(uc, mycpu)->env, *(uint32_t *)value, 0xffffffffu);
+                    break;
                 case UC_ARM_REG_APSR:
                     cpsr_write(&ARM_CPU(uc, mycpu)->env, *(uint32_t *)value, (CPSR_NZCV | CPSR_Q | CPSR_GE));
                     break;
diff --git a/qemu/translate-all.c b/qemu/translate-all.c
index 2deddd1..f92aedb 100644
--- a/qemu/translate-all.c
+++ b/qemu/translate-all.c
@@ -441,8 +441,13 @@ static PageDesc *page_find_alloc(struct uc_struct *uc, tb_page_addr_t index, int
     /* We can't use g_malloc because it may recurse into a locked mutex. */
 # define ALLOC(P, SIZE)                                 \
     do {                                                \
-        P = mmap(NULL, SIZE, PROT_READ | PROT_WRITE,    \
-                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);   \
+       void* _tmp = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, \
+                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); \
+       if (_tmp == (void*)-1) { \
+         qemu_log(">>> Out of memory for stack, bailing out. <<<\n"); \
+         exit(1); \
+       } \
+       (P) = _tmp; \  \
     } while (0)
 #else
 # define ALLOC(P, SIZE) \
